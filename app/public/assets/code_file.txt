/*
  HOW TO PLAY THE GAME

  - HACK BY MASHING YOUR KEYBOARD
  - KEEP THE HACK BAR IN THE MIDDLE FOR OPTIMAL HACKING
  - INVITE YOUR FRIENDS BY SENDING THEM THIS LINK TO HACK TOGETHER
  - SPECIAL EVENTS OCCASIONALLY HAPPEN AND YOU NEED TO PRESS THE RIGHT SHORTCUT
  - BUT THEY ARE NOT ALWAYS ON YOUR SCREEN
  - TRY TO GET THE MOST HACKER CRED!
  
  GOOD LUCK,
  ANON
*/

struct group_info init_groups = { .usage = ATOMIC_INIT(2) };

struct group_info *groups_alloc(int gidsetsize){

	struct group_info *group_info;

	int nblocks;

	int i;



	nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;

	/* Make sure we always allocate at least one indirect block pointer */

	nblocks = nblocks ? : 1;

	group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);

	if (!group_info)

		return NULL;

	group_info->ngroups = gidsetsize;

	group_info->nblocks = nblocks;

	atomic_set(&group_info->usage, 1);



	if (gidsetsize <= NGROUPS_SMALL)

		group_info->blocks[0] = group_info->small_block;

	else {

		for (i = 0; i < nblocks; i++) {

			gid_t *b;

			b = (void *)__get_free_page(GFP_USER);

			if (!b)

				goto out_undo_partial_alloc;

			group_info->blocks[i] = b;

		}

	}

	return group_info;



out_undo_partial_alloc:

	while (--i >= 0) {

		free_page((unsigned long)group_info->blocks[i]);

	}

	kfree(group_info);

	return NULL;

}



EXPORT_SYMBOL(groups_alloc);



void groups_free(struct group_info *group_info)

{

	if (group_info->blocks[0] != group_info->small_block) {

		int i;

		for (i = 0; i < group_info->nblocks; i++)

			free_page((unsigned long)group_info->blocks[i]);

	}

	kfree(group_info);

}

0	0	1	0	1	1	1	0	1	0	0	0	1	0	0
1	1	1	1	0	0	0	0	1	0	1	1	0	0	0
0	1	1	0	0	1	1	0	1	1	0	0	1	0	1
0	0	1	0	0	0	1	1	1	1	0	1	0	0	0
0	0	1	1	1	1	1	1	1	1	0	0	0	0	1
0	1	1	1	0	1	0	1	0	1	1	0	1	0	1
0	1	0	1	1	0	0	0	1	0	1	1	1	1	0
1	1	0	0	1	0	0	0	1	0	0	1	1	1	1
1	1	0	0	0	1	0	0	1	1	1	0	1	1	0
1	1	0	1	0	1	0	0	0	1	1	1	0	1	1
1	0	1	1	1	1	1	0	0	1	0	0	1	1	1
0	1	1	1	0	0	0	0	1	0	0	1	0	0	0
0	0	0	0	1	0	1	1	0	1	0	0	0	0	1
1	1	1	0	0	0	1	0	0	1	0	0	1	1	0
1	0	0	1	0	0	1	0	0	1	1	1	0	1	1
0	1	1	1	0	1	1	1	0	0	0	1	1	1	1
0	1	1	1	1	0	0	1	0	0	0	1	0	0	1
0	1	0	0	0	0	1	1	1	0	0	0	1	1	0
1	0	1	1	0	0	1	0	0	0	0	1	1	0	1
0	1	0	1	1	0	0	1	0	1	1	1	1	0	1
0	0	0	1	0	1	1	1	0	0	0	1	1	1	1

EXPORT_SYMBOL(groups_free);



/* export the group_info to a user-space array */

static int groups_to_user(gid_t __user *grouplist,

			  const struct group_info *group_info)

{

	int i;

	unsigned int count = group_info->ngroups;



	for (i = 0; i < group_info->nblocks; i++) {

		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);

		unsigned int len = cp_count * sizeof(*grouplist);



		if (copy_to_user(grouplist, group_info->blocks[i], len))

			return -EFAULT;



		grouplist += NGROUPS_PER_BLOCK;

		count -= cp_count;

	}

	return 0;

}

$ ping google.com
PING google.com (216.58.193.78): 56 data bytes
64 bytes from 216.58.193.78: icmp_seq=0 ttl=56 time=83.690 ms
64 bytes from 216.58.193.78: icmp_seq=1 ttl=56 time=83.508 ms
64 bytes from 216.58.193.78: icmp_seq=2 ttl=56 time=83.325 ms
64 bytes from 216.58.193.78: icmp_seq=3 ttl=56 time=105.532 ms
--- google.com ping statistics ---
16 packets transmitted, 16 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 82.087/88.561/108.383/8.877 ms

/* fill a group_info from a user-space array - it must be allocated already */

static int groups_from_user(struct group_info *group_info,

    gid_t __user *grouplist)

{

	int i;

	unsigned int count = group_info->ngroups;



	for (i = 0; i < group_info->nblocks; i++) {

		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);

		unsigned int len = cp_count * sizeof(*grouplist);



		if (copy_from_user(group_info->blocks[i], grouplist, len))

			return -EFAULT;



		grouplist += NGROUPS_PER_BLOCK;

		count -= cp_count;

	}

	return 0;

}



/* a simple Shell sort */

static void groups_sort(struct group_info *group_info)

{

	int base, max, stride;

	int gidsetsize = group_info->ngroups;



	for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)

		; /* nothing */

	stride /= 3;



	while (stride) {

		max = gidsetsize - stride;

		for (base = 0; base < max; base++) {

			int left = base;

			int right = left + stride;

			gid_t tmp = GROUP_AT(group_info, right);



			while (left >= 0 && GROUP_AT(group_info, left) > tmp) {

				GROUP_AT(group_info, right) =

				    GROUP_AT(group_info, left);

				right = left;

				left -= stride;

			}

			GROUP_AT(group_info, right) = tmp;

		}

		stride /= 3;

	}

}



/* a simple bsearch */

int groups_search(const struct group_info *group_info, gid_t grp)

{

	unsigned int left, right;



	if (!group_info)

		return 0;



	left = 0;

	right = group_info->ngroups;

	while (left < right) {

		unsigned int mid = left + (right - left)/2;

		if (grp > GROUP_AT(group_info, mid))

			left = mid + 1;

		else if (grp < GROUP_AT(group_info, mid))

			right = mid;

		else

			return 1;

	}

	return 0;

}


─────────▄──────────────▄
────────▌▒█───────────▄▀▒▌
────────▌▒▒▀▄───────▄▀▒▒▒▐
───────▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐
─────▄▄▀▒▒▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐
───▄▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀██▀▒▌
──▐▒▒▒▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄▒▒▌
──▌▒▒▐▄█▀▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐
─▐▒▒▒▒▒▒▒▒▒▒▒▌██▀▒▒▒▒▒▒▒▒▀▄▌
─▌▒▀▄██▄▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒▒▒▌
─▌▀▐▄█▄█▌▄▒▀▒▒▒▒▒▒░░░░░░▒▒▒▐
▐▒▀▐▀▐▀▒▒▄▄▒▄▒▒▒▒▒░░░░░░▒▒▒▒▌
▐▒▒▒▀▀▄▄▒▒▒▄▒▒▒▒▒▒░░░░░░▒▒▒▐
─▌▒▒▒▒▒▒▀▀▀▒▒▒▒▒▒▒▒░░░░▒▒▒▒▌
─▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐
──▀▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▒▒▒▒▌
────▀▄▒▒▒▒▒▒▒▒▒▒▄▄▄▀▒▒▒▒▄▀
───▐▀▒▀▄▄▄▄▄▄▀▀▀▒▒▒▒▒▄▄▀
──▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀▀

/**

 * set_groups - Change a group subscription in a set of credentials

 * @new: The newly prepared set of credentials to alter

 * @group_info: The group list to install

 *

 * Validate a group subscription and, if valid, insert it into a set

 * of credentials.

 */

int set_groups(struct cred *new, struct group_info *group_info)

{

	put_group_info(new->group_info);

	groups_sort(group_info);

	get_group_info(group_info);

	new->group_info = group_info;

	return 0;

}



EXPORT_SYMBOL(set_groups);



/**

 * set_current_groups - Change current's group subscription

 * @group_info: The group list to impose

 *

 * Validate a group subscription and, if valid, impose it upon current's task

 * security record.

 */

int set_current_groups(struct group_info *group_info)

{

	struct cred *new;

	int ret;



	new = prepare_creds();

	if (!new)

		return -ENOMEM;



	ret = set_groups(new, group_info);

	if (ret < 0) {

		abort_creds(new);

		return ret;

	}



	return commit_creds(new);

}



EXPORT_SYMBOL(set_current_groups);



SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)

{

	const struct cred *cred = current_cred();

	int i;



	if (gidsetsize < 0)

		return -EINVAL;



	/* no need to grab task_lock here; it cannot change */

	i = cred->group_info->ngroups;

	if (gidsetsize) {

		if (i > gidsetsize) {

			i = -EINVAL;

			goto out;

		}

		if (groups_to_user(grouplist, cred->group_info)) {

			i = -EFAULT;

			goto out;

		}

	}

out:

	return i;

}



/*

 *	SMP: Our groups are copy-on-write. We can set them safely

 *	without another task interfering.

 */



SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)

{

	struct group_info *group_info;

	int retval;



	if (!nsown_capable(CAP_SETGID))

		return -EPERM;

	if ((unsigned)gidsetsize > NGROUPS_MAX)

		return -EINVAL;



	group_info = groups_alloc(gidsetsize);

	if (!group_info)

		return -ENOMEM;

	retval = groups_from_user(group_info, grouplist);

	if (retval) {

		put_group_info(group_info);

		return retval;

	}



	retval = set_current_groups(group_info);

	put_group_info(group_info);



	return retval;

}

                                             �t	�y.-L/}D�7���7&`<��t�br(�{<��h�����줥���vꆏ2ZN���a��ޢ�ņ�f��=�0i���	���RaE 7L���ssG"���6���!�jX��&�&�@��T痡��Ic۵�`$�ƙJ��BKa���Qgi<2T1]�tlG�jU�.�d��r�o=&��cz����t�53�YΙ�[%�2Oس%�5�j�՜f�Y몙h����x�ˇ0��-f#�f	FcMIR(�c%�+m$THRD,��=����V|I��9�u0�8�_�Q�?#$�J�:S�{���:���>ekA��fw��%�z�l�q��u�S��OҲ[R��#ͅBK���s���kb��r)�r^*�S�����"�2u�F#
                                                                   (��9��Z0?]�.μ��	%�mV��W���gA�i��In�;{���e���Nr��RrH�?�Jx���e;G���h��s�h������!P �sq��v�F~Ao�SzR�u�NGթu��^��>;*�SL��Z�1�	�!Y���p�Q��Hz.U�~��=��
               [�گ��
���Ѩh8��h�hÙ8R
              �h�D�~s�+�=�Y�(c�a��P�2�ɋYQ���Jű�t,a�QK
�6�]M��L�,��U(��&+*���g�]�}N�Ǘ坴�:R���^��m��A�I���OB>S�+��)8�M��B�`�a2�#��EFC����?!��?R�'U��R����cm������*Q��;4��itU�bi)$�Ǽ)����E
                          �թ��w�|�6r�Kx8�eJ}A�A�e,ӳa�[�)������Ya�@�(�qh_���W����MDNl�$��|)��1
                                                                                             z-��a��D^�������@^�!$o��Ye�\�D�	��4����e�/Y4��)"�	O��a>�F��\��LR�ē­{����=*NkVө��/�������9��rz�	mcU�{eg��
���a�2�:�'�ޠ?8rg��`N/�>ˈ�(%��!��t�
                                  ���B3�`I���T����f
                                                   3�P���j�f�*]���P���ż\/�J:d�P��b��3q~�ط�q(R��'��tk$:.��8�_��o�`rE:_غ5i����L!t�
�T��T���!��)uCSl�?A�g�4`9�#��MI���ݍ9倰�G�:h$|��PD=��{@���^C^�9�u�\M�6/�Ms ��l�


/*

 * Check whether we're fsgid/egid or in the supplemental group..

 */

int in_group_p(gid_t grp)

{

	const struct cred *cred = current_cred();

	int retval = 1;



	if (grp != cred->fsgid)

		retval = groups_search(cred->group_info, grp);

	return retval;

}



EXPORT_SYMBOL(in_group_p);



int in_egroup_p(gid_t grp)

{

	const struct cred *cred = current_cred();

	int retval = 1;



	if (grp != cred->egid)

		retval = groups_search(cred->group_info, grp);

	return retval;

}